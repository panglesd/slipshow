open Types

module Record = struct
  module V1 = struct
    type event = Stroke of V1.Stroke.t | Erase of float [@@deriving yojson]

    let _ = Erase 1.0

    type t = event list [@@deriving yojson]
    (** Ordered by time *)

    type record = { start_time : float; evs : t } [@@deriving yojson]

    let of_string s =
      match s |> Yojson.Safe.from_string with
      | x -> of_yojson x
      | exception Yojson.Json_error _ -> Error "Not a json file"

    let to_string r =
      r |> to_yojson |> fun x ->
      `Assoc [ ("version", `String "1"); ("record", x) ]
      |> Yojson.Safe.to_string
  end

  include V1

  let of_string s =
    let ( let* ) = Result.bind in

    let sep s =
      match String.index_from_opt s 0 '\n' with
      | None ->
          Error
            "Badly formed draw file. Must contain at least two lines: the \
             first with the version, the rest with the content."
      | Some i ->
          Ok (String.sub s 0 i, String.sub s (i + 1) (String.length s - (i + 1)))
    in
    let* version, content = sep s in
    match version with
    | "v1" ->
        let* _comment, content = sep content in
        V1.of_string content
    | v ->
        Error
          ("Draw files must start with their version. But I found an unknown \
            version: " ^ v)

  let to_string s =
    let concat v s = v ^ "\n" ^ s in
    let s = V1.to_string s in
    let with_comments =
      concat
        "This file has been generated by slipshow! The line above gives the \
         version of the syntax for the file, the line below is the actual \
         content. Beware when modifying!"
        s
    in
    concat "v1" with_comments

  let current_record = ref None
  let now () = Brr.Performance.now_ms Brr.G.performance
  let empty_record () = { start_time = now (); evs = [] }
  let start_record () = current_record := Some (empty_record ())

  let stop_record () =
    let res = !current_record in
    current_record := None;
    Option.map (fun res -> res.evs) res

  let relativize_path starting_time path =
    List.map (fun (pos, t) -> (pos, t -. starting_time)) path

  let relativize_event starting_time event =
    match event with
    | Stroke ev ->
        let path = relativize_path starting_time ev.path in
        let end_at = ev.end_at -. starting_time in
        Stroke { ev with path; end_at }
    | Erase t -> Erase (t -. starting_time)

  let record (event : event) =
    match !current_record with
    | None -> ()
    | Some current_record_val ->
        let event = relativize_event current_record_val.start_time event in
        let evs = event :: current_record_val.evs in
        let current_record_val = { current_record_val with evs } in
        current_record := Some current_record_val
end

let svg_path options scale path =
  let path =
    List.rev_map
      (fun ((x, y), _) -> Perfect_freehand.Point.v (x *. scale) (y *. scale))
      path
  in
  let stroke = Perfect_freehand.get_stroke ~options path in
  let svg_path = Perfect_freehand.get_svg_path_from_stroke stroke in
  Jstr.to_string svg_path

let continue_shape coord =
  match !State.current_drawing_state with
  | Drawing (el, stroke) ->
      let t = Record.now () in
      let stroke =
        { stroke with path = (coord, t) :: stroke.path; end_at = t }
      in
      State.current_drawing_state := Drawing (el, stroke);
      Brr.El.set_at (Jstr.v "d")
        (Some (Jstr.v (svg_path stroke.options stroke.scale stroke.path)))
        el
  | Erasing last_point ->
      Hashtbl.iter
        (fun _id (elem, { Stroke.path; _ }) ->
          let intersect = Utils.intersect_poly path (coord, last_point) in
          let close_enough = Utils.close_enough_poly path coord in
          if intersect || close_enough then State.Strokes.remove_el elem)
        State.Strokes.all;
      State.current_drawing_state := Erasing coord;
      ()
  | Pointing -> ()

let create_elem_of_stroke
    { Stroke.options; scale; color; opacity; id; path; end_at = _ } =
  let p = Brr.El.v ~ns:`SVG (Jstr.v "path") [] in
  let set_at at v = Brr.El.set_at (Jstr.v at) (Some (Jstr.v v)) p in
  set_at "fill" (Color.to_string color);
  set_at "id" id;
  let () =
    let scale = 1. /. scale in
    let scale = string_of_float scale in
    Brr.El.set_inline_style (Jstr.v "transform")
      (Jstr.v @@ "scale3d(" ^ scale ^ "," ^ scale ^ "," ^ scale ^ ")")
      p
  in
  set_at "opacity" (string_of_float opacity);
  Brr.El.set_at (Jstr.v "d") (Some (Jstr.v (svg_path options scale path))) p;
  p

let options_of stroke width =
  let size =
    match (stroke, width) with
    | Tool.Pen, Width.Small -> 6.
    | Pen, Medium -> 10.
    | Pen, Large -> 14.
    | Highlighter, Small -> 28.
    | Highlighter, Medium -> 38.
    | Highlighter, Large -> 48.
  in
  Perfect_freehand.Options.v ~thinning:0.5 ~smoothing:0.5 ~size ~streamline:0.5
    ~last:false ()

let start_shape id ({ State.tool; _ } as state) coord =
  let svg =
    Brr.El.find_first_by_selector (Jstr.v "#slipshow-drawing-elem")
    |> Option.get
  in
  match tool with
  | Tool.Stroker stroker ->
      let opacity = match stroker with Tool.Highlighter -> 0.33 | Pen -> 1. in
      let end_at = Record.now () in
      let path = [ (coord, end_at) ] in
      let options = options_of stroker state.width in
      let { Universe.Coordinates.scale; _ } = Universe.State.get_coord () in
      let stroke =
        {
          Stroke.path;
          options;
          opacity;
          id;
          color = state.color;
          scale;
          end_at;
        }
      in
      let p = create_elem_of_stroke stroke in
      State.current_drawing_state := Drawing (p, stroke);
      Brr.El.append_children svg [ p ]
  | Eraser -> State.current_drawing_state := Erasing coord
  | Pointer -> ()

let end_shape () =
  (match !State.current_drawing_state with
  | Drawing (el, stroke) ->
      let s = Stroke.to_string stroke in
      Brr.Console.(log [ "a stroke is: "; s ]);
      Record.record (Record.Stroke stroke);
      Hashtbl.add State.Strokes.all stroke.id (el, stroke)
  | _ -> ());
  State.current_drawing_state := Pointing

let clear () =
  Hashtbl.iter
    (fun _ (elem, _) -> State.Strokes.remove_el elem)
    State.Strokes.all

module Replay = struct
  open Record

  let replay_stroke ?(speedup = 1.) (stroke : Stroke.t) =
    Brr.Console.(log [ "Replaying stroke" ]);
    let start_time = now () in
    let el = create_elem_of_stroke { stroke with path = [] } in
    let svg =
      Brr.El.find_first_by_selector (Jstr.v "#slipshow-drawing-elem")
      |> Option.get
    in
    Brr.El.append_children svg [ el ];
    let filter () =
      let time_elapsed = now () -. start_time in
      let rec loop acc = function
        | [] -> (acc, true)
        | ((_, t) as hd) :: tl when t <= speedup *. time_elapsed ->
            loop (hd :: acc) tl
        | _ :: _ -> (acc, false)
      in
      loop [] (List.rev stroke.path)
    in
    let rec draw_loop _ =
      let path, finished = filter () in
      Brr.El.set_at (Jstr.v "d")
        (Some (Jstr.v (svg_path stroke.options stroke.scale path)))
        el;
      if finished then ()
      else
        let _animation_frame_id = Brr.G.request_animation_frame draw_loop in
        ()
    in
    let _animation_frame_id = Brr.G.request_animation_frame draw_loop in
    ()

  let start_time = function
    | Stroke { path = (_, t) :: _; _ } | Erase t -> t
    | Stroke { path = []; _ } -> failwith "TODO" (* TODO: implement *)

  let replay ?(speedup = 1.) (record : t (* record *)) =
    let fut, resolve_fut = Fut.create () in
    let start_replay = now () in
    let filter l speedup =
      let time_elapsed = now () -. start_replay in
      let rec loop acc = function
        | [] -> (acc, [])
        | ev :: tl when start_time ev <= speedup *. time_elapsed ->
            loop (ev :: acc) tl
        | rest -> (acc, rest)
      in
      loop [] l
    in
    let rec draw_loop l _ =
      let speedup =
        match Fast.get_mode () with Normal -> speedup | _ -> 10000.
      in
      Brr.Console.(log [ "l has length"; List.length l ]);
      let to_draw, rest = filter l speedup in
      List.iter
        (function
          | Stroke s -> replay_stroke ~speedup s
          | Erase _ -> failwith "TODO" (* TODO: implement *))
        to_draw;
      match rest with
      | [] -> resolve_fut ()
      | _ :: _ ->
          let _animation_frame_id =
            Brr.G.request_animation_frame (draw_loop rest)
          in
          ()
    in
    let _animation_frame_id =
      Brr.G.request_animation_frame (draw_loop (List.rev record))
    in
    fut

  let stroke_until ~time_elapsed (stroke : Stroke.t) =
    let path = List.filter (fun (_, t) -> t <= time_elapsed) stroke.path in
    let el = create_elem_of_stroke { stroke with path } in
    el

  let draw_until ~elapsed_time (record : t) =
    List.concat_map
      (fun event ->
        let time = start_time event in
        if elapsed_time >= time then
          let time_elapsed = elapsed_time -. time in
          match event with
          | Stroke s -> [ stroke_until ~time_elapsed s ]
          | _ -> failwith "TODO" (* TODO: DO *)
        else [])
      record
end
