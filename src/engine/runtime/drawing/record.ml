module V1 = struct
  type 'a timed = 'a * float [@@deriving yojson]

  type event =
    (* Stroke of V1.Stroke.t | Erase of string list timed *)
    [ `Draw of Tools.Draw.event
    | `Erase of Tools.Erase.event
    | `Clear of Tools.Clear.event ]
  [@@deriving yojson]

  type t = { events : event timed list; record_id : int } [@@deriving yojson]
  (** Ordered by time *)

  type record = { start_time : float; evs : t } [@@deriving yojson]

  let of_string s =
    match s |> Yojson.Safe.from_string with
    | x -> of_yojson x
    | exception Yojson.Json_error _ -> Error "Not a json file"

  let to_string r = r |> to_yojson |> Yojson.Safe.to_string
end

include V1

let of_string s =
  let ( let* ) = Result.bind in

  let sep s =
    match String.index_from_opt s 0 '\n' with
    | None ->
        Error
          "Badly formed draw file. Must contain at least two lines: the first \
           with the version, the rest with the content."
    | Some i ->
        Ok (String.sub s 0 i, String.sub s (i + 1) (String.length s - (i + 1)))
  in
  let* version, content = sep s in
  match version with
  | "v1" ->
      let* _comment, content = sep content in
      V1.of_string content
  | v ->
      Error
        ("Draw files must start with their version. But I found an unknown \
          version: " ^ v)

let to_string s =
  let concat v s = v ^ "\n" ^ s in
  let s = V1.to_string s in
  let with_comments =
    concat
      "This file has been generated by slipshow! The line above gives the \
       version of the syntax for the file, the line below is the actual \
       content. Beware when modifying!"
      s
  in
  concat "v1" with_comments

type recording_in_progress = record ref

let now () = Brr.Performance.now_ms Brr.G.performance

let empty_record record_id =
  { start_time = now (); evs = { events = []; record_id } }

let new_id () = Random.int 1000000
let start_record () = ref (empty_record (new_id ()))

let stop_record current_record =
  let res = !current_record in
  res.evs

let relativize_event starting_time (event, time) = (event, time -. starting_time)

let record (event : event) record =
  let event = (event, now ()) in
  let current_record_val = !record in
  let event = relativize_event current_record_val.start_time event in
  let evs =
    {
      current_record_val.evs with
      events = event :: current_record_val.evs.events;
    }
  in
  let current_record_val = { current_record_val with evs } in
  record := current_record_val

let () = ignore record
