open Types

type 'a timed = 'a * float [@@deriving yojson]

module V1 = struct
  type event = Stroke of V1.Stroke.t | Erase of string list timed
  [@@deriving yojson]

  let _ = Erase ([], 1.0)

  type t = event list [@@deriving yojson]
  (** Ordered by time *)

  type record = { start_time : float; evs : t } [@@deriving yojson]

  let of_string s =
    match s |> Yojson.Safe.from_string with
    | x -> of_yojson x
    | exception Yojson.Json_error _ -> Error "Not a json file"

  let to_string r = r |> to_yojson |> Yojson.Safe.to_string
end

include V1

let of_string s =
  let ( let* ) = Result.bind in

  let sep s =
    match String.index_from_opt s 0 '\n' with
    | None ->
        Error
          "Badly formed draw file. Must contain at least two lines: the first \
           with the version, the rest with the content."
    | Some i ->
        Ok (String.sub s 0 i, String.sub s (i + 1) (String.length s - (i + 1)))
  in
  let* version, content = sep s in
  match version with
  | "v1" ->
      let* _comment, content = sep content in
      V1.of_string content
  | v ->
      Error
        ("Draw files must start with their version. But I found an unknown \
          version: " ^ v)

let to_string s =
  let concat v s = v ^ "\n" ^ s in
  let s = V1.to_string s in
  let with_comments =
    concat
      "This file has been generated by slipshow! The line above gives the \
       version of the syntax for the file, the line below is the actual \
       content. Beware when modifying!"
      s
  in
  concat "v1" with_comments

type recording_in_progress = record ref

(* let current_record = ref None *)
let now () = Brr.Performance.now_ms Brr.G.performance
let empty_record () = { start_time = now (); evs = [] }
let start_record () = ref (empty_record ())

let stop_record current_record =
  let res = !current_record in
  res.evs

let relativize_path starting_time path =
  List.map (fun (pos, t) -> (pos, t -. starting_time)) path

let relativize_event starting_time event =
  match event with
  | Stroke ev ->
      let path = relativize_path starting_time ev.path in
      let end_at = ev.end_at -. starting_time in
      Stroke { ev with path; end_at }
  | Erase (ids, t) -> Erase (ids, t -. starting_time)

let record (event : event) record =
  let current_record_val = !record in
  let event = relativize_event current_record_val.start_time event in
  let evs = event :: current_record_val.evs in
  let current_record_val = { current_record_val with evs } in
  record := current_record_val

let () = ignore record
